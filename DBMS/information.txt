1)File system v/s Database system = https://www.geeksforgeeks.org/difference-between-file-system-and-dbms/
2)Users of Database system = https://www.geeksforgeeks.org/different-types-of-database-users/
3)Data independence = https://www.geeksforgeeks.org/data-abstraction-and-data-independence/
4)DBMS system architecture = DBMS system architecture
5)Entity-Relationship (ER) Model = https://www.geeksforgeeks.org/introduction-of-er-model/
6)Entity-Relationship (EER) Model :Generalization, Specialization and Aggregation = https://www.geeksforgeeks.org/generalization-specialization-and-aggregation-in-er-model/
7)Mapping the ER and EER Model to the Relational Model = https://www.geeksforgeeks.org/mapping-from-er-model-to-relational-model/
8)Relational Algebra = https://www.geeksforgeeks.org/introduction-of-relational-algebra-in-dbms/
9)Data Definition Commands, Data Manipulation commands, Data Control
commands, Transaction Control Commands. = https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/
https://www.w3schools.com/sql/sql_foreignkey.asp
10)group by order by  = https://www.geeksforgeeks.org/difference-between-order-by-and-group-by-clause-in-sql/
https://www.javatpoint.com/group-by-vs-order-by
11) having = https://www.tutorialspoint.com/sql/sql-having-clause.htm
https://www.programiz.com/sql/having

Aggregate funcs = max, min, avg, count, sum. 
Other select funcs = in, not in, between, is null, is not null

12)SQL views = https://www.programiz.com/sql/views
13)SQL joins = https://www.programiz.com/sql/join
14)Keys = https://www.javatpoint.com/dbms-keys
15)Integrity constraints = https://www.scaler.com/topics/dbms/integrity-constraints-in-dbms/
RED K = red key
16)Triggers = https://www.javatpoint.com/triggers-in-sql-server
17)Anomalies in dbms = https://www.geeksforgeeks.org/anomalies-in-relational-model/
assume student and courses table combined and now imagine insert, update, delete operations on it.
https://www.geeksforgeeks.org/the-problem-of-redundancy-in-database/
18)pitfalls in relational database design = photo
19)ACID = https://www.geeksforgeeks.org/acid-properties-in-dbms/
20)Serializability – Conflict and View = to-do
21)Concurrency Control: Lock-based, Timestamp-based protocols = 
https://www.tutorialspoint.com/dbms/dbms_concurrency_control 
https://www.geeksforgeeks.org/timestamp-based-concurrency-control/
22)Failure classification = https://www.geeksforgeeks.org/failure-classification-in-dbms/
23)log based recovery, ARISE, Checkpoint = 
https://www.geeksforgeeks.org/log-based-recovery-in-dbms/
https://www.geeksforgeeks.org/algorithm-for-recovery-and-isolation-exploiting-semantics-aries/
24)shadow paging = 
https://www.geeksforgeeks.org/shadow-paging-dbms/
25)deadlock handling =
https://www.geeksforgeeks.org/deadlock-in-dbms/
https://www.geeksforgeeks.org/race-condition-vulnerability/
26)Resource allocation graph and bankers algorithm = to-do jenney's lectures.


-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

Functional Dependency =
x-->y 
x here is determinant and y is dependent. so y is dependent on x and x determines y. ie. if we are given x then we can y from the table.
For one value of x we will have only one value for y and there cannot be other y value record in table with that x value.
Roll number of every student is different and two students can have same names. eg. rollNo --> student names
so in general = if t1.x==t2.x then t1.y==t2.y , t1 and t2 are two tuples.
value of x should be unique in every record then x will determine y in table.
x and y can be set of attributes.

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

Types of functional dependencies =
Trivial, non-trivial, multivalued, transitive
1)Trivial = if x-->y and y is a subset of x. 
x-->x is a functional dependency.
Eg. (rollNo,name)-->name OR (rollNo,name)-->rollNo
Trivial functional dependency is always valid. because dependent is present in determinant itself. No need to check if trivial dependency is valid or not. 

2)Non-trivial = if x-->y and x intersection y is NULL. i.e. nothing common in x and y
Eg. rollNo --> name 
Noe-trivial dependency maybe valid or may not be valid. we need to check table.

3)semi-trivial = if x-->y and y is not a subset of x.
Eg. (rollNo, name) --> (name,marks)

------------------------------------------------------------------------------------------------------------- 
-------------------------------------------------------------------------------------------------------------

Armstrong's Axioms / Inference rules => To find out all the functional dependencies in a table.
1)reflexivity = x-->x OR x-->y with y as subset of x. ie. trivial dependencies
2)transitivity = if x-->y and y-->z then x-->z. 
3)Augumentation = if x-->y then (x,a)-->(y,a)
4)Union = if x-->y and x-->z then x-->(y,z)
5)decomposition/splitting = if x-->(y,z) then x-->y and x-->z
                            if (x,y)-->z then this may not be true that x-->z or y-->z
6)pseudo transitivity = if x-->y and (y,z)-->a then (x,z)-->a
7)composition = if x-->y and a-->b then (x,a)-->(y,b)

RAT UDP C

Attribute closure / closure set => to find number of candidate keys in relation
closure of x is = contains all the attributes determined by x.
Eg.
R(A,B,C,D,E)
Functional dependency = {A-->B,B-->C,C-->D,D-->E}

so from this using all the inference rules we can determine that=
A-->A,A-->B,A-->C,A-->D,A-->E so A-->ABCDE
B-->B,B-->D,B-->E so B-->BCDE

closure of A = {A,B,C,D,E}
closure of AD = {A,B,C,D,E} becasue A can determine all attributes.
closure of B = {B,C,D,E}

shortcut to find a closure is just iterate over function dependencies and chekc if you have determinant in your closure currently, if yes then include dependent in closure else ignore it.

A,AD,AB,AC etc are super key here. And A is a candidate key.
super key = set of attributes whose closure contains all the attributes given in a relation.
candidate key = minimal super key OR super key whose proper subset is not a super key.

How to find number of candidate keys in relation (shortcut) =>
Eg. R(A,B,C,D,E)
FD = {A-->B,D-->E}

1)start with all attributes,
closure of ABCDE = {A,B,C,D,E}
2)check FD, A-->B so we can discard B because A can determine B
closure of ACDE = {A,B,C,D,E}
3)check FD, D-->E so we can discard E because D can determine E
closure of ACD = {A,B,C,D,E}
4)Now FD set is over so finally we have ACD is final super key.
Try to check proper subsets of ACD = A,C,D,AC,AD,DC
5)this is the shortcut to get candidate key.

( check transitivity property as well while iterating over FD set )

prime attributes = attributes part of candidate key ie. A,C,D are all prime attributes.

check if your prime attributes are available on right hand side of FDs. If A,C,D are not available on right hand side of any FD then we will not find any other candidate key.

Eg.
R(A,B,C,D)
FD = {A-->B,B-->C,C-->A}

after following steps we will get AD as candidate key
Here prime attr={A,D} but A is present on right hand side of FD in C-->A
so we can replace A with C and that is also super key for that relation ie. CD is also super key and could be an candidate key.(check that)
Similarly C is added to prime attr = {A,D,C}
But C is present on right hand side in FD in B-->C so replace C with B and BD will be a super key for relation and could be an candidate key.(check that)
final candidate keys = AD,CD,BD

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

Keys in DBMS =>
keys are used to access each record uniquely. we already have unique column names but we need something unique in rows to pinpoint the daata we want in table.
1)super key = is an attribute or set of attributes that uniquely identifies each record in a relation.
data in that attribute column should be unique in each record.
2)candidate key = its a super key whose proper subset is not a super key. ie. minimal super key.
Eg. for super key of {ABC} proper subsets of it are A,B,C,AB,AC,BC. but ABC is not proper subset of it.
3)primary key = one candidate key from set is used as primary key. It should not have any null values. Remaining candidate keys are considered as secondary or alternate keys.
There is no constraint on primary, candidate key to have only one attribute, it can have set of attributes.
4)foreign key = primary key from some other table.

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

1NF =>
rules-
1)All the attributes should have atomic values. ie. one value in each cell
Ie. you cannot have p1,p2 in phone number column. you should seperate it into two records.
2)A column should contain values from same domain ie. if a column has ints then it cannot have string for some records.
3)each column should have unique name.
4)no top-down ordering to the rows and no left-right ordering to the columns.
5)no duplicate rows.
6)every table should have a primary key.
composite attributes should be divided into seperate columns And multivalued attribute should be divided in seperate rows.

table example =
columns = sid,sname,saddr,phoneNo
FD = sid --> sname,saddr,phoneNo.
But one student can have multiple phone numbers so we should not write them in single cell with commas. we should make seperate records for each phone number.

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

2NF =>
rules-
1)relation should be in 1NF.
2)no partial dependency in relation.
what is partial functional dependency = proper subset of candidate key determines non-prime attribute.
prime attributes = attributes which are part of candiddate keys.
Eg. R(A,B,C,D,E,F)
FD = {A-->B,B-->C,C-->D,D-->E}
super key = AF
candidate key = AF
proper subsets of candidate key = {A,F}
non-prime attributes = {B,C,D,E}

is A or F determining any non-prime attribute -> yes.
so there is partial dependency.

If candidate key is having only one attribute than proper subset of it will be empty so we can say relation is in 2NF.

To convert a relation in 2NF we can decompose table.

table example = 
columns = std_id, course_no, course_fee
FD = { (std_id,course_no)-->course_fee, course_no-->course_fee }
candidate key = (std_id,course_no)
proper subset of candidate key can determine non prime attr ie. course_no --> course_fee so it violates 2NF


-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

3NF =>
anomalies present in table that is in 2NF =

Eg,
sid,sname,DOB,state,country,pincode,credits.
here sid is primary key and its the only candidate key. so prime attributes = sid.

here pincode-->state,country , if we want to update state of a pincode then we will have to update it in multiple rows because maultiple students might have same pincode and state.
this can cause update anomoly.
we can decompose this table in two tables => sid,sname,DOB,credits,pincode and pincode,state,country

1)table should be in 2NF for it to be in 3NF
2)table should not have transitive dependency among non-prime attributes to be in 3NF.
ie. non prime attr --> non prime attr
as in our example pincode,state,country all were non prime attrs.

shortcut =
A table is in 3NF if and only if for each of its nontrivial functional dependency at least one of the following conditions holds-
1)LHS is SK
2)RHS is prime attr.

table example =
columns = STUD_NO,STUD_NAME,STUD_STATE,STUD_COUNTRY,STUD_AGE
FD = {STUD_NO -> STUD_NAME, STUD_NO -> STUD_STATE, STUD_STATE -> STUD_COUNTRY, STUD_NO -> STUD_AGE}
candiate key = {STUD_NO}
here nonprime attr --> non prime attr ie. STUD_STATE -> STUD_COUNTRY

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

BCNF =>
advanced version of 3NF
1)table should be in 3NF for it to be in BCNF
2)for each non-trivial dependency the LHS of dependency (ie. determinant) must be super key.
This is more strict than 3NF because we want LHS of dependency should be a super key and in 3NF the rules are either LHS is super key or RHS is prime attribute
The problem that can arise with 3NF is Nonprime attr --> prime attr , this relation is valid 3NF but invalid BCNF.

-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

4NF =>
1)It should be in the Boyce-Codd Normal Form (BCNF).
2)The table should not have any Multi-valued Dependency.
For a dependency A → B, if for a single value of A, multiple values of B exists, then the relation will be a multi-valued dependency.
-------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------

References =>
1) https://www.geeksforgeeks.org/normal-forms-in-dbms/ = for 1NF,2NF,3NF,BCNF
2) https://www.javatpoint.com/dbms-forth-normal-form = for 4NF
3) https://www.youtube.com/watch?v=MjwaP18s0Xs&list=PLdo5W4Nhv31b33kF46f9aFjoJPOkdlsRc&index=3  = jenney's lectures