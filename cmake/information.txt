1) CMake is a build system generator that is platform- and compiler-independent. That means you don’t need to rewrite code for CMake again when you want to port your project from one system to another. CMake also has its own language, called the CMake language.cmake is used to compile project with platform and compiler independent way.
it generates makefiles

2) How to use Cmake to build a simple cpp project.
cmake --version => check cmake version installed on system
create a CMakeLists.txt file.
mkdir build => required for cmake
cd build
cmake ../ => to execute CMakeLists.txt, this command generates the makefile for the project in build folder (ie. current folder).
cmake --build . => creates a executable in build folder (ie. current folder).

3)cmake for simple hello world cpp file
cmake_minimum_required(VERSION 3.16.3)
project(Hello)
add_executable(hello hello.cpp)

To set cpp20 and set compilation flags we can use these =
set(CMAKE_CXX_STANDARD 20)
SET(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_CXX_FLAGS "-Wall -Werror -O2 -march=native")

To make a shared library =
cmake_minimum_required(VERSION 3.16.3)
project(Math)
add_library(math SHARED add.cpp multiply.cpp)
add_executable(main main.cpp)
target_link_libraries(main math)
This creates a "main" executable and "libmath.so" shared library in build folder.
we can directly run main executable in build directory without setting LD_LIBRARY_PATH because cmake sets it for us. check "ldd main"

4) Recursive cmake
If we have a project divided in directories then we can have one CMakeLists.txt file for every directory.
Eg.
we have this directory structure=
-project 
--> main = main.cpp, CMakeLists.txt
--> math = add.cpp, multiply.cpp, add.h, multiply.h, CMakeLists.txt
--> CMakeLists.txt

main.cpp includes "add.h" and "multiply.h" and uses functions from it.
we want to make shared library in math directory and have a executable from main.cpp.

CMakeLists.txt from math directory =
add_library(math SHARED add.cpp multiply.cpp)
target_include_directories(math PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}) #expose header files = here CMAKE_CURRENT_SOURCE_DIR is math, because of this line main.cpp can use -> #include "math.h" instead of #include "../math/math.h"

CMakeLists.txt from main directory =
add_executable(main main.cpp)
target_link_libraries(main math)

CMakeLists.txt from project directory =
cmake_minimum_required(VERSION 3.16.3)
project(recursive)
add_subdirectory(main)
add_subdirectory(math)

Now how to build it=
mkdir build
cd build
cmake ../ => This makes two folder inside build directory math and main. Each folder has Makefile. 
cmake --build .  => main executable will be present in main folder and libmath.so file will be present in main folder.
./main => this executable is final output. "ldd main" shows libmath.so is present.

5) Huge Cmake tutorial = https://medium.com/@onur.dundar1/cmake-tutorial-585dd180109b#:~:text=Introduction,with%20the%20native%20build%20environment.

6) "cmake .. -G Ninja" command generates these files for Ninja. Then run "ninja" command to generate executable
This is similay to using make , "cmake .." and "make" commands would generate same executable.
So cmake can be used with GNU make and ninja both.

7) how to create only object file using cmake =

For eg. we have three files test.h, test.cpp and main.cpp. we are using a function declared in from test.h in main.cpp.
so we can create a object file from test.cpp and then use that object file along with main.cpp to create final executable.

cmake_minimum_required(VERSION 3.16.3)
project(Hello)
add_library(testobj OBJECT test.cpp)
add_executable(hello $<TARGET_OBJECTS:testobj> hello.cpp)

read more about object libraries = https://cmake.org/cmake/help/latest/command/add_library.html#object-libraries

7) https://julienjorge.medium.com/an-overview-of-build-systems-mostly-for-c-projects-ac9931494444
https://www.linkedin.com/pulse/modern-build-systems-comparative-analysis-gnu-make-cmake-ninja/

8) How to add an include directory to the compiler's include path =>
you can use the -I flag with both gcc and g++ compilers. This flag specifies the directory to be added to the list of directories to be searched for header files.
let's say we have this following directory structure-
project/
├── src/
│   └── main.cpp
├── include/
│   └── myheader.h

In main.cpp we will use -> #include "myheader.h" instead of -> #include "../include/myheader.h" 
g++ -I./include -o main src/main.cpp = compiles main.cpp and Adds the include directory to the compiler's include path.
./main  = to run executable

How to do this with cmake =>
project/
├── src/
│   └── main.cpp
├── include/
│   └── myheader.h
└── CMakeLists.txt

cmake_minimum_required(VERSION 3.16.3)
project(MyProject)
add_executable(myTarget src/main.cpp)
target_include_directories(myTarget PRIVATE ${CMAKE_SOURCE_DIR}/include)

INTERFACE: All the include directories following INTERFACE will NOT be used for the current target but will be accessible for the other targets that have dependencies on the current target.
PUBLIC: All the directories following PUBLIC will be used for the current target and the other targets that have dependencies on the current target
PRIVATE: All the include directories following PRIVATE will be used for the current target only.

9)Differnce in angular brackets and double quotes in "include" statement in cpp =>
Angle Brackets (< >): The compiler searches the system include directories and any directories specified by the -I option in the command line. It does not look in the directory of the including file.

Double Quotes (" "): The compiler first searches the directory of the including file. If it does not find the file there, it then searches the system include directories and any directories specified by the -I option.

system include directories = /usr/include on Unix-like systems or the directories specified in the compiler's settings

-------------------
References
1)https://youtu.be/k8-ShLBcN8Q?si=7QUpMDIfQRqL3dv8
2)https://youtu.be/4VAuaPDX-j4?si=JvAcmKC3bRB-nItD
3)https://youtu.be/MjrJZ10fb0s?si=FLs-pu9yGXG2Yyvd