1) Makefile has rules.
so rule has target, it has prerequisits and it has recipe.
target = whatever we want to build with this rule
prerequisits = this we need  before we can build this target.
recipe = how we are going to build the target.

make file syntax =
<target>:<prereq>
    <recipe>

For eg. to compile simple hello.cpp file we can write a Makefile
hello: hello.cpp
    g++ hello.cpp -o  hello

run "make" command to get executable. If you run "make" command again then it would not rebuild executable adn will show "make: 'hello' is up to date."
because it can detect that nothing is changed in hello.cpp

2)we can use variables in Makefile
hello: hello.cpp
	g++ $^ -o $@

"$^" copies all the prereq and "$@" copies name of the target.

3)To run a specific rule from make file we can sue this command = "make <targetName>"

4)To add dependency of rules, for eg we have add.cpp, add.h and print_add.cpp which uses add function.
Makefile =
add.o: add.cpp
	g++ -c $^ -o $@
print_add.o: print_add.cpp
	g++ -c $^ -o $@
print_add_main: print_add.o add.o
	g++ $^ -o $@

here "print_add_main" target depends on other two targets "add.o" and "print_add.o"
we need to run "make print_add_main" to get all object filea and executable, if we run only "make" then it generates only "add.o"
to fix this we can add this section in Makefile =

all: print_add_main

Now if we run "make" then it builds all object files and executable.

5)clean
we can write a section to cleanup the project.
clean:
    rm <executableName> *.o

"make clean" command removed executable and all object files.

6) PHONY targets =
If we have a file called "clean" in the folder then "make clean" will show "clean already up to date". because make thinks that with "make clean" we are asking it to build clean file which is already up to date. so to tell Makefile that "clean" is a command we want to execute, we can make "clean" a phony target.

.PHONY: clean
clean:
	rm print_add_main *.o

7) recursive make
If we have 2 folders int_math and float_math. 
Both folders have cpp files and Makefile to build shared library.
then we can write a single makefile in root folder to execute makefiles from int_math and float_math folders.

SUBDIRS = int_math float_math
libraries:
	for dir in $(SUBDIRS); do $(MAKE) -C $$dir; done
.PHONY: clean
clean:
	for dir in $(SUBDIRS); do $(MAKE) -C $$dir clean; done
	
The problem with this Makefile is we execute int_math makefile first and then float_math makefile, although they are not dependent on each other. so we can execute them in parallel using following Makefile -

SUBDIRS = int_math float_math
.PHONY: libraries
libraries: $(SUBDIRS)
.PHONY: $(SUBDIRS)
$(SUBDIRS):
	$(MAKE) -C $@
.PHONY: clean
clean:
	for dir in $(SUBDIRS); do $(MAKE) -C $$dir clean; done

here "$(SUBDIRS)" generates two different targets and executes them in parallel.

8) when we run "make" command on Makefile then it executes first target mentioned in Makefile.
so we make a target "all:" before all targets and in that target we mention the first target we want to execute as prereq.

-----------
References
1)https://youtu.be/7MTpvVdKDzE?si=LymNVp8z3sNbiSk4
2)https://youtu.be/TXI2BUvrgQ8?si=OBYw70Z0bQaqj2pL
3)https://youtu.be/19erwS0OCKY?si=Bf9YoqcBW1VKRyPu